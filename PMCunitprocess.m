function[Normdsumsig,sumsig,RayNormSig,M,sumsmdM,sumdM,B,RayRemoval] = PMCunitprocess(Info,RawCnt,HammingFWHM,system);% function[Normdsumsig,sumsig,RayNormSig,head,sizeofhead,Rawbino,M,sumsmdM,sumdM,B,RayRemoval]=ProcessUnitData(mdy,system,sp,Rawbinwid,chopperyn,ConstantBase,binrange,HammingFWHM,PlotRayFigure,bkgfit);%% Constants and parameters (declare global variables)global pi c Me Qe E0 kB AMU Radiusglobal Deadtime_PMT Deadtime_Disc SigmaL MAX_Countrateglobal vert_bin_res Rayleigh_sum_start_alt Rayleigh_sum_end_alt Rayleigh_fit_alt BG_start_alt2 BG_end_alt2global Rayleigh_fit_start_alt Rayleigh_fit_end_alt Rayleigh_norm_alt Fe_start_alt Fe_end_alt BG_start_alt BG_end_altglobal time_adjust Hamming_widthglobal smonth zulumonthglobal PMTsaturation_correction_yn Chopper_correction_yn Background_fit_yn Smooth_PhotonCnt_yn PlotRayFigure_ynglobal BaseAlt latitude longitude%% Data information transferred from mainprocess.m and setprocess.myear = Info(1,1);month = Info(1,2);day = Info(:,3);time = Info(:,4);ShotsNum = Info(:,5);BinTime = Info(1,6);Rawbinwid = BinTime/2*1e-9*c;   % Bin width (unit: m), considering round-tripNumofProfile = size(RawCnt,1);  % number of profiles in the unit time intervalBinNum = size(RawCnt,2);        % total bin number in each profile%% Preprocess raw data for each unit time-bin (e.g., an hour)% Bin Number Corresponding to Absolute Altitude for% RayStart, RayEnd, FeStart, FeEnd, BgStart, BgEndbino4RayStart = round(Rayleigh_fit_start_alt/Rawbinwid);bino4RayEnd = round(Rayleigh_fit_end_alt/Rawbinwid);bino4RayNorm = round(Rayleigh_norm_alt/Rawbinwid);bino4FeStart = round(Fe_start_alt/Rawbinwid);bino4FeEnd = round(Fe_end_alt/Rawbinwid);bino4BgStart = round(BG_start_alt/Rawbinwid);bino4BgEnd = round(BG_end_alt/Rawbinwid);bino4BaseAlt = round(BaseAlt/Rawbinwid);sumsig = zeros(1,BinNum);			% for signal calculation (with z^2)sumrawsig = zeros(1,BinNum);M = zeros(1,BinNum);				% for photon noise calculation (without z^2)sumvarsmdM = zeros(1,BinNum);		% error variance when integrate profilessumsmdM = zeros(1,BinNum);			% photon error after smooth and integrate profilessumvardM = zeros(1,BinNum);			% error variance when integrate profiles but without smoothsumdM = zeros(1,BinNum);			% photon error after integrate profiles but without smoothB = 0;                  			% background for error calculationfor mm = 1:NumofProfile    rawsig = RawCnt(mm,:);          % raw data profile transferred from mainprocess.m and setprocess.m	sumrawsig = sumrawsig + rawsig; % raw photon counts for photon noise calculation    % plot((1:BinNum)*Rawbinwid/1000,rawsig,'r'); axis([0 200 0 20000]); pause(0.2)        %% PMT saturation correction    if (PMTsaturation_correction_yn == 1)        sig = SaturationCorrectionVector(rawsig,BinTime/1000,BinNum,ShotsNum(mm));                            % BinTime must be in micro-second unit (us)        % plot((1:BinNum)*Rawbinwid/1000,rawsig,'r',(1:BinNum)*Rawbinwid/1000,sig,'-c'); pause    elseif (PMTsaturation_correction_yn == 0)        sig = rawsig;    end		%% Chopper correction	if (Chopper_correction_yn == 1)		if (mm == 1)			if(input('Chopper Curve Exist?0=No 1=Yes:') == 0)	            [ChopperCurve] = GetChopperCurve(mdy,system,Rawbinwid,BinNum);			else				if(system == 1)			        load(sprintf('/Users/chu/Tiger/ScienceProjects/Rothera/DataProcess/%s%02d%02d/DataSTAT/ChopperCurve374.dat',smonth(month,:),day,year2))					ChopperCurve = ChopperCurve374;                elseif (system == 2)			        load(sprintf('/Users/chu/Tiger/ScienceProjects/Rothera/DataProcess/%s%02d%02d/DataSTAT/ChopperCurve372.dat',smonth(month,:),day,year2))					ChopperCurve = ChopperCurve372;				end			end		end		sig = sig./ChopperCurve;    end        %% Background subtraction, range-dependence removal, and integration in time    if (Background_fit_yn == 0)        dM = sqrt(rawsig);			% photon count noise for each raw bin	        %% Smooth photon counts and each bin error by Hamming window        if (Smooth_PhotonCnt_yn == 1)            [smoothsig,smdM] = HammingSmoothN(sig,dM,HammingFWHM);        elseif (Smooth_PhotonCnt_yn == 0)            smoothsig = sig;    % for not to smooth the data            smdM = dM;			% for not to smooth the data        end        %% Subtract constant background and remove range-dependence        puresig = (smoothsig-mean(smoothsig(bino4BgStart-bino4BaseAlt:bino4BgEnd-bino4BaseAlt))).*(((1:BinNum)*Rawbinwid).^2);            %% Integrate Profiles        sumsig = sumsig + puresig;				% integrate photon counts (with z^2)        M = M + smoothsig;						% integrate photon counts for error calculation (without z^2)        sumvarsmdM = sumvarsmdM + smdM.^2;		% integrate photon noise variance        sumvardM = sumvardM + dM.^2;			% integrate photon noise variance without smooth (for Rayleigh and Bkg)        B = B + mean(smoothsig(bino4BgStart-bino4BaseAlt:bino4BgEnd-bino4BaseAlt));    elseif (Background_fit_yn == 1 )        %% Integrate profiles before subtracting background, smoothing photons, and removing range-dependence        sumsig = sumsig + sig;    endendif (Background_fit_yn == 0)    sumsmdM = sqrt(sumvarsmdM);		% integrate photon noise (for PMC)    sumdM = sqrt(sumvardM);			% integrate photon noise without smooth (for Rayleigh and Bkg)endif (Background_fit_yn == 1)    sumdM = sqrt(sumsig);     % photon noise without smooth (for Rayleigh and Bkg)    [M,nonuse] = HammingSmoothN(sumsig,sumdM,HammingFWHM);    % integrate photon counts for error calculation (without z^2)    B = mean(sumsig(bino4BgStart-bino4BaseAlt:bino4BgEnd-bino4BaseAlt));    %% estimate background using linear fit to log-scale data (tilted or constant)    xdata = (bino4BgStart-bino4BaseAlt:bino4BgEnd-bino4BaseAlt);    ydata = log(sumsig(bino4BgStart-bino4BaseAlt:bino4BgEnd-bino4BaseAlt));       % exponential decay?    f = inline('x(1)+x(2)*xdata','x','xdata');    x0(1) = mean(ydata);    x0(2) = 0;    x = lsqcurvefit(f,x0,xdata/1000,ydata);    %sprintf('%.9f     %.9f',x)    bkg = exp(f(x,(1:BinNum)/1000));          % exponential decay?    figure; plot((1:BinNum)*Rawbinwid/1000,sumsig,'-k',(1:BinNum)*Rawbinwid/1000,bkg,'--r');   % to plot raw signal and fitted background    axis([30 180 mean(sumsig(bino4BgStart-bino4BaseAlt:bino4BgEnd-bino4BaseAlt))-500 mean(sumsig(bino4BgStart-bino4BaseAlt:bino4BgEnd-bino4BaseAlt))+500]); pause(0.5)    %% subtract fitted background        puresig = (sumsig-bkg);    %% smooth integrated photon counts    [sumsig,sumsmdM] = HammingSmoothN(puresig,sumdM,HammingFWHM);    %% remove range dependence    sumsig = sumsig.*(((1:BinNum)*Rawbinwid).^2);end%% Add base altitude to the sum signal and errornewsig = zeros(1,BinNum+bino4BaseAlt);newM = zeros(1,BinNum+bino4BaseAlt);newsmdM = zeros(1,BinNum+bino4BaseAlt);newunsmdM = zeros(1,BinNum+bino4BaseAlt);		% un-smoothed dMnewsig(1+bino4BaseAlt:BinNum+bino4BaseAlt) = sumsig;newM(1+bino4BaseAlt:BinNum+bino4BaseAlt) = M;newsmdM(1+bino4BaseAlt:BinNum+bino4BaseAlt) = sumsmdM;		% smoothed dMnewunsmdM(1+bino4BaseAlt:BinNum+bino4BaseAlt) = sumdM;		% un-smoothed dMsumsig = newsig(1:BinNum);		% sum photon counts (with z^2)M = newM(1:BinNum);				% sum photon counts (without z^2)sumsmdM = newsmdM(1:BinNum);		% smoothed photon noisesumdM = newunsmdM(1:BinNum);		% un-smoothed photon noise%% Get Rayleigh normalization counts @ Rayleigh normalization altitude for Fe and PMC computation% Smooth Rayleigh Signal by Hamming WindowHammingFWHMBin = 5; %smthsig = HammingSmooth(sumsig,HammingFWHMBin);smthsig = sumsig;% Rayleigh Fitfity = log(max(smthsig(bino4RayStart:bino4RayEnd),1));		% change to natural log scalemx = (bino4RayStart + bino4RayEnd)/2*Rawbinwid;     % mean for x-axis											my = mean(fity);                                    % mean for y-axisfitx = (bino4RayStart:bino4RayEnd)*Rawbinwid-mx;					fity = fity-my;								% shift to around originslope = sum(fitx.*fity)/sum(fitx.^2);			% slope of linear fitSH = -1/slope;								% scale height% Get the range-dependence-removed Rayleigh signal at 50kmRNSig = exp(my);RayNormSig = exp(mean(log(smthsig(bino4RayStart:bino4RayEnd)))); %RayNormSig = exp(mean(log(max(smthsig(bino4RayStart:bino4RayEnd),0.01))));% Plot Rayleigh Fit in Log Scaleif (PlotRayFigure_yn == 1)%     scrsz=get(0,'ScreenSize');%     figure('position',[700 500 scrsz(3)*0.4 scrsz(4)*0.4])%     subplot('Position',[0.15,0.15,0.75,0.75])    plot((1:BinNum)*Rawbinwid*1e-3,log(max(1,smthsig)),'g')%     axis([0 150 6 26])    hold on    plot((bino4RayStart:bino4RayEnd)*Rawbinwid*1e-3,slope*fitx+my,'r')					    hold off; grid on    xlabel(sprintf('Altitude (km), Scale Height = %3.2f km',SH*1e-3))    ylabel('Photon Counts')    if (system == 1)        title(sprintf('374nm Channel on %d %s %04d at %3.2f-%3.2f UT', day(1), smonth(month,:), year, time(1), time(end)))    elseif (system == 2)        title(sprintf('372nm Channel on %d %s %04d at %3.2f-%3.2f UT', day(1), smonth(month,:), year, time(1), time(end)))    endend% to compute Rayleigh signal removal for error calculationRayRemoval = exp(((bino4FeStart:bino4FeEnd).*Rawbinwid-mx)*slope+my);%% Normalize integrated profile by Rayleigh signal at 50 kmNormdsumsig = sumsig./RayNormSig;if imag(Normdsumsig)>0   disp('imaginary number Normdsumsig ') end